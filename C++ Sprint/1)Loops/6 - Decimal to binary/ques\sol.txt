Problem Statement:
Write a program that takes a non-negative decimal (base-10) integer as input and converts it to its binary (base-2) representation using a while loop.
â€•
You must build the binary representation manually â€“ do not use built-in conversion functions (like bin() in Python).
Input:
A single non-negative integer n (0 â‰¤ n â‰¤ 1,000,000)
Output:
A string representing the binary form of the input number.
Examples:
Input:
5
Output: 101


** Solution **


We repeatedly:

Divide the number by 2

Record the remainder (0 or 1)

Prepend it to a string (since binary digits are calculated in reverse)


Steps:
Step	n	n % 2	Binary (built backward)
1	    5	1	    "1"
2	    2	0	    "01"
3	    1	1	    "101"
4	    0	â€”	    -

âš ï¸ Edge Case:
If the input is 0, we directly print 0 since the loop wonâ€™t run.



ğŸ”¢ Problem:
Convert a non-negative integer (like 5) into its binary representation (like 101) using only a while loop, no built-in functions, and no strings-to-binary tricks.

ğŸ“˜ Binary Basics:
Binary is base-2, so each digit is either 0 or 1.

To convert a decimal to binary:

Divide the number by 2

Store the remainder

Keep dividing the result until the number becomes 0

The binary is the reversed order of remainders

âœ… Example: Convert 5 to binary
Step-by-step math:
5 Ã· 2 = 2 remainder 1   â† Least significant bit (LSB)
2 Ã· 2 = 1 remainder 0
1 Ã· 2 = 0 remainder 1   â† Most significant bit (MSB)
Now collect the remainders bottom-up: 1 0 1

â†’ So, binary of 5 is 101


{string binary = "";}
We create a string to store our binary number (as characters '0' or '1').


{    while (n > 0) {
        int remainder = n % 2;
        binary = char(remainder + '0') + binary;
        n = n / 2;
    }
}
Letâ€™s break this part down:s
ğŸ§© n % 2:
Gets the last bit (remainder when dividing by 2)

Will always be 0 or 1

ğŸ§© char(remainder + '0'):
Converts 0 or 1 to a character

'0' has ASCII value 48, so:

0 + '0' = '0'

1 + '0' = '1'

ğŸ§© binary = ... + binary:
We prepend each new bit at the front

Because the first remainder is the last bit, and so on

ğŸ§© n = n / 2:
We reduce n for the next step